                        Một số điều cần biết về Javascript
Javascript Runtime và Javascript Engine
    JS Runtime & Engine
        JS Runtime: Xét trong môi trường browser(trình duyệt)
        Đối với môi trường browser có 4 thành phần chính để giúp Javascript có thể chạy được cũng như xử lý được 
            các task vụ bất đồng bộ: Js Engine, 
        Trong đó có thành phần quan trọng nhất là Js Engine
        Còn lại 3 thành phần khác là: Timers, XHR, DOM giúp cho Js có thể quản lý được các task vụ bất đồng bộ bao gồm
            Web APIs, Even Loops và Callback Queues
        Js là 1 ngôn ngữ đơn luồng(Single Thread), ko thể thực thi song song cùng 1 lúc 2 task vụ được
Execution Context
    Khi 1 đoạn chương trình Javascript được chạy thì Javascript Engine luôn luôn khởi tạo mới 1 Execution Context để theo 
        dõi và và qản lý và giám sát trình tự thực thi
    Đoạn chương trình này có thể là 1 chương trình con hoặc toàn bộ ứng dụng khi khởi chạy lần đầu tiên 
        Chương trình chính(App): Global Execution Context 
        Chương trình con: Local Execution Context
    Khi Js Engine tạo ra một Execution Context thì nó luôn luôn qua 2 giai đoạn: Creation Phase và Execution Phase 
Creation Phase(Giai đoạn khởi tạo)
    - Setup memory(Variables Envionments)
    - Định nghĩa Scope Chain 
        - Global Scope
        - Script Scope 
        - Block Scope 
        - Function Scope 
    - Ràng buộc từ khóa this (Ngoại trừ Arrow Function)
        - Default binding
        - Implicit binding 
        - Explicit binding
    Khi chạy 1 app có Global memory: global = window = this 
    var: tầm vực global memory 
    let, const: Tầm vực Script Scope
Practice
    Practice 01
        debugger
            Call Stack
                (anonymous)     hoising.js:1  -> Dòng code đang thực thi
            Scope: Script, Global
                2 tầm vực Script, Global vì đang chạy file hoising.js và các biến đang được khai báo ở cấp cao nhất của file
            Global              Window
                age, getFullName vì được khai báo bằng var
                calAge vì được khai báo bằng function
            Script: 
                firstName, lastName, yearOfBirth vì được khai báo bằng let và const. Ngoài ra nếu các biến này được khai báo 
                    trong các block {}, như if, else chẳng hạn thì sẽ có tầm vực là Block. Hoặc khai báo trong function thì 
                    có tầm vực là function
    hoising:  Khi Javascript khi một Execution Context được khởi tạo thì nó luôn luôn qua 2 giai đoạn: 
        Creation Phase(khởi tạo) set up buộc nhớ để lưu lại
        Execution Phase
    Temporal Dead Zone(TDZ)
        Liên quan đến từ khóa let và const
        // Start TDZ
        // Không thể truy cập age khi chưa khai báo let age = 30
        // console.log(age);
        let age = 30; // End TDZ
        C:\xampp\htdocs\javascript_advance\01_js_to_know\04_Temporal_Dead_Zone\tdz.js
        TDZ luôn luôn được khởi tạo khi bắt đầu 1 tầm vực mới và bên trong đó có sử dụng từ khóa let 
        Trong khu vực TDZ này ko thể sử dụng, truy cập được vào biến hay gán biến đó cho 1 giá trị, khi khởi tạo biến age thì sẽ kết 
            thúc khu vực TDZ 
        Khi muốn chia sẻ dữ liệu giữa 2 Scope khác nhau thì bắt buộc phải đẩy lên cấp cao hơn
        Cấp cao hơn tầm vực Script là Scope Global(window, this)
        window, this: giúp chia sẻ dữ liệu giữa 2 file 
            window.hello='world'
            this.course='Javascript'
    Practice 02
    Practice 03
        Scope được hình thành trong giai đoạn Creation Phase phụ thuộc vào vị trí khai báo hàm chứ không phụ thuộc vào 
            vị trí gọi hàm 
Parameters và Arguments
    Function parameters là những tham số (variables) được đặt tên và liệt kê trong phần khai báo (định nghĩa) của một hàm
    Function arguments là những đối số đã được xác định giá trị được truyền vào hàm tại thời điểm thực thi hàm đó.
First Class Objects trong Javascript
    First Class Objects là những đối tượng cụ thể (entity, instance) trong lập trình mà tại thời điểm thực thi nó có thể được 
        truyền như là một argument, được gán cho một biến bất kỳ hoặc có thể được return từ một function khác
    First Class Function trong Javascript:
        Function trong Javascript cũng được coi như 1 Objects cho nên 1 function có thể được truyền vào trong 1 function khác,
            gán vào trong 1 biến, return 1 function ở bên trong 1 function khác
Higher Order Functions và Callbacks
    Higher order functions là những hàm thỏa một trong hai điều kiện sau:
        Có thể nhận một function khác như là một đối số (argument)
        Output là một function
    Có rất nhiều Function cốt lõi của Javascript sử dụng cơ chế này khiến cho mã nguồn dễ đọc, đễ hiểu hơn
        như map, filter, reduce, ..
    function cloneArrayAndDoSomething(arrInput, func) {
        var arrOutput = [];
        for(var idx = 0; idx < arrInput.length; idx++) {
            arrOutput.push(
                func( arrInput[idx] );
            )
        }
        return arrOutput;
    }
    const handleAdd3 = function(num) {
        return num + 3;
    }
    const result = cloneArrayAndDoSomething(arr, handleAdd3);
    func: Là Callback vì ở đây chỉ truyền tham chiếu của hàm vào thôi, thực tế hàm được gọi lại khi hàm cloneArrayAndDoSomething
        được thực thi 
    Callback: Gọi lại sau 
Closure trong Javascript
    Khi 1 hàm được khởi tạo thì Closure cũng được tạo theo, tức là tại thời điểm tạo ra hàm thì 1 Closure sẽ 
        được gắn kèm với nó chứa tất cả các biến nằm ngoài tầm vực của hàm đó. Tức là 1 Closure sẽ cho phép 
        1 function ở bên trong được phép truy cập vào những giá trị của function ở bên ngoài
    Trong innerFunc sử dụng giá trị nào ở bên ngoài thì Closure sẽ lưu các giá trị đó
    function outerFunc() {
    let number = 20;
    let course = 'Javascript nâng cao';
    console.log("[scope outerFunc]", course);
    function innerFunc() {
        let number2 = 50;
        let total = number2 + number;
        console.log("[scope innerFunc]", total);
        return total;
    }
    return innerFunc;
    }
    const func = outerFunc();
    const result = func();
Implicit Binding and This keyword
    this được ràng buộc (binding) vào một Execution Context(ngữ cảnh thực thi) mỗi khi Execution Context này được khởi tạo
    Khi nào Execution Context được khởi tạo khi
        Khi gọi hàm (Execution Context) -> this có thể thay đổi tùy theo từng hàm
        Khi chạy ứng dụng (Global Execution Context)
    Có 3 kiểu ràng buộc this:
        Implicit Binding (Ràng buộc ngầm)
            Thông qua dot notation 
            ex: john.sum(10, 20);
        Explicit Binding (Ràng buộc tường minh)
            Do lập trình viên quyết định
            Sử dụng các method có sẵn (built-in) của Javascript
                .bind(this)
                .call(this, arg1, arg2, ...)
                .apply(this, [arg1, arg2, ...])
        Default Binding (Ràng buộc mặc định)
            Mặc định ràng buộc globalThis = window
            ex:
                var func = john.sum;
                func(10, 20);
            Trường hợp mặc định này thì nó cũng đúng với các function bình thường khi gọi biến this trong function đó 
Explicit Binding, bind, call và apply
    Bind
        Là 1 method có sãn của Javascript, truyền vào 1 object bất kỳ. Object này sẽ được ràng buộc vào biến this 
        Khi gọi hàm bind() thì nó sẽ trả về 1 function mới đã được dàng buộc cố định object mà mình đã truyền vào 
        Có thể sử dụng hàm bind này để cố định this
    Call và apply
        Nhận vào một object bất kỳ trong tham số đầu tiên
        Function này sẽ được gọi ngay lập tức
        Return về kết quả của lời gọi hàm
Practice 04
    Arrow function không được ràng buộc this:
        Phụ thuộc vào nơi khai báo function
        Sử dụng this như là scope của function bên ngoài. 
            this của arrow function được coi như là Closure ở bên ngoài tức là Scope Chain ở bên ngoài
            -> chính là this của function bên ngoài nó 
        Để có thể truy cập được this chính là object hiện tại thì không được phép khai báo là arrow function
Strict mode
    const btnEl = document.getElementById('test-this')
    const john = {
        addEvent() {
            btnEl.addEventListener('click', this.handleClick);
        },
        handleClick() {
            console.log('handleClick', this);
        }
    }
    this.handleClick ở đây thực hiện vai trò truyền hàm vào Javascript Dom chứ ko phải thực hiện gọi hàm theo kiểu dot notation.
        Khi trình duyệt nhận diện được sự kiện của người dùng là click thì môi trường trình duyệt và môi trường Dom giúp ta gọi 
            hàm này
    
            ==========================================================================================================

                        Asynchronous Programming

Concurrency, Parallelism
    Concurrency (Đồng thời): Là khi hai hay nhiều tác vụ có thể bắt đầu xử lý, đang xử lý và hoàn tất trong
        khoảng thời gian chồng chéo lên nhau.(overlapping time).
        Trong 1 thời điểm nó chỉ xử lý 1 task vụ thôi, nếu task vụ này quá tốn thời gian, cần phải chờ thì có thể tạm dừng task 
            vụ đó để chèn task vụ khác lên và xử lý tiếp. Khi task vụ khác xử lý xong thì sẽ quay trở lại task vụ đang chờ để xủ lý
    Parallelism (Song song): Là khi hai hay nhiều tác vụ có thể bắt đầu xử lý, đang xử lý và hoàn tất trong
        chính xác cùng một thời điểm -> Java
    Javascript Concurrency Modal
Single Thread và Blocking
    Javascript là ngôn ngữ lập trình đơn luồng.
    Đơn luồng: Tại một thời điểm chỉ có duy nhất một câu lệnh được thực thi.
    Thực thi theo kiểu đồng bộ từng dòng
    Blocking: Javascript chỉ xử lý đơn luồng nên dẫn đến vấn đề là Blocking, là đoạn code sẽ bị chặn khi mà đoạn code ở phía trên chưa 
        xử lý xong
    