                        Một số điều cần biết về Javascript
Javascript Runtime và Javascript Engine
    JS Runtime & Engine
        JS Runtime: Xét trong môi trường browser(trình duyệt)
        Đối với môi trường browser có 4 thành phần chính để giúp Javascript có thể chạy được cũng như xử lý được 
            các task vụ bất đồng bộ: Js Engine, 
        Trong đó có thành phần quan trọng nhất là Js Engine
        Còn lại 3 thành phần khác là: Timers, XHR, DOM giúp cho Js có thể quản lý được các task vụ bất đồng bộ bao gồm
            Web APIs, Even Loops và Callback Queues
        Js là 1 ngôn ngữ đơn luồng(Single Thread), ko thể thực thi song song cùng 1 lúc 2 task vụ được
Execution Context
    Khi 1 đoạn chương trình Javascript được chạy thì Javascript Engine luôn luôn khởi tạo mới 1 Execution Context để theo 
        dõi và và qản lý và giám sát trình tự thực thi
    Đoạn chương trình này có thể là 1 chương trình con hoặc toàn bộ ứng dụng khi khởi chạy lần đầu tiên 
        Chương trình chính(App): Global Execution Context 
        Chương trình con: Local Execution Context
    Khi Js Engine tạo ra một Execution Context thì nó luôn luôn qua 2 giai đoạn: Creation Phase và Execution Phase 
Creation Phase(Giai đoạn khởi tạo)
    - Setup memory(Variables Envionments)
    - Định nghĩa Scope Chain 
        - Global Scope
        - Script Scope 
        - Block Scope 
        - Function Scope 
    - Ràng buộc từ khóa this (Ngoại trừ Arrow Function)
        - Default binding
        - Implicit binding 
        - Explicit binding
    Khi chạy 1 app có Global memory: global = window = this 
    var: tầm vực global memory 
    let, const: Tầm vực Script Scope
Practice
    Practice 01
        debugger
            Call Stack
                (anonymous)     hoising.js:1  -> Dòng code đang thực thi
            Scope: Script, Global
                2 tầm vực Script, Global vì đang chạy file hoising.js và các biến đang được khai báo ở cấp cao nhất của file
            Global              Window
                age, getFullName vì được khai báo bằng var
                calAge vì được khai báo bằng function
            Script: 
                firstName, lastName, yearOfBirth vì được khai báo bằng let và const. Ngoài ra nếu các biến này được khai báo 
                    trong các block {}, như if, else chẳng hạn thì sẽ có tầm vực là Block. Hoặc khai báo trong function thì 
                    có tầm vực là function
    hoising:  Khi Javascript khi một Execution Context được khởi tạo thì nó luôn luôn qua 2 giai đoạn: 
        Creation Phase(khởi tạo) set up buộc nhớ để lưu lại
        Execution Phase
    Temporal Dead Zone(TDZ)
        Liên quan đến từ khóa let và const
        // Start TDZ
        // Không thể truy cập age khi chưa khai báo let age = 30
        // console.log(age);
        let age = 30; // End TDZ
        C:\xampp\htdocs\javascript_advance\01_js_to_know\04_Temporal_Dead_Zone\tdz.js
        TDZ luôn luôn được khởi tạo khi bắt đầu 1 tầm vực mới và bên trong đó có sử dụng từ khóa let 
        Trong khu vực TDZ này ko thể sử dụng, truy cập được vào biến hay gán biến đó cho 1 giá trị, khi khởi tạo biến age thì sẽ kết 
            thúc khu vực TDZ 
        Khi muốn chia sẻ dữ liệu giữa 2 Scope khác nhau thì bắt buộc phải đẩy lên cấp cao hơn
        Cấp cao hơn tầm vực Script là Scope Global(window, this)
        window, this: giúp chia sẻ dữ liệu giữa 2 file 
            window.hello='world'
            this.course='Javascript'
    Practice 02
    Practice 03
        Scope được hình thành trong giai đoạn Creation Phase phụ thuộc vào vị trí khai báo hàm chứ không phụ thuộc vào 
            vị trí gọi hàm 
Parameters và Arguments
    Function parameters là những tham số (variables) được đặt tên và liệt kê trong phần khai báo (định nghĩa) của một hàm
    Function arguments là những đối số đã được xác định giá trị được truyền vào hàm tại thời điểm thực thi hàm đó.
First Class Objects trong Javascript
    First Class Objects là những đối tượng cụ thể (entity, instance) trong lập trình mà tại thời điểm thực thi nó có thể được 
        truyền như là một argument, được gán cho một biến bất kỳ hoặc có thể được return từ một function khác
    First Class Function trong Javascript:
        Function trong Javascript cũng được coi như 1 Objects cho nên 1 function có thể được truyền vào trong 1 function khác,
            gán vào trong 1 biến, return 1 function ở bên trong 1 function khác
Higher Order Functions và Callbacks
    Higher order functions là những hàm thỏa một trong hai điều kiện sau:
        Có thể nhận một function khác như là một đối số (argument)
        Output là một function
    Có rất nhiều Function cốt lõi của Javascript sử dụng cơ chế này khiến cho mã nguồn dễ đọc, đễ hiểu hơn
        như map, filter, reduce, ..
    function cloneArrayAndDoSomething(arrInput, func) {
        var arrOutput = [];
        for(var idx = 0; idx < arrInput.length; idx++) {
            arrOutput.push(
                func( arrInput[idx] );
            )
        }
        return arrOutput;
    }
    const handleAdd3 = function(num) {
        return num + 3;
    }
    const result = cloneArrayAndDoSomething(arr, handleAdd3);
    func: Là Callback vì ở đây chỉ truyền tham chiếu của hàm vào thôi, thực tế hàm được gọi lại khi hàm cloneArrayAndDoSomething
        được thực thi 
    Callback: Gọi lại sau 
Closure trong Javascript
    Khi 1 hàm được khởi tạo thì Closure cũng được tạo theo, tức là tại thời điểm tạo ra hàm thì 1 Closure sẽ 
        được gắn kèm với nó chứa tất cả các biến nằm ngoài tầm vực của hàm đó. Tức là 1 Closure sẽ cho phép 
        1 function ở bên trong được phép truy cập vào những giá trị của function ở bên ngoài
    Trong innerFunc sử dụng giá trị nào ở bên ngoài thì Closure sẽ lưu các giá trị đó
    function outerFunc() {
    let number = 20;
    let course = 'Javascript nâng cao';
    console.log("[scope outerFunc]", course);
    function innerFunc() {
        let number2 = 50;
        let total = number2 + number;
        console.log("[scope innerFunc]", total);
        return total;
    }
    return innerFunc;
    }
    const func = outerFunc();
    const result = func();
Implicit Binding and This keyword
    this được ràng buộc (binding) vào một Execution Context(ngữ cảnh thực thi) mỗi khi Execution Context này được khởi tạo
    Khi nào Execution Context được khởi tạo khi
        Khi gọi hàm (Execution Context) -> this có thể thay đổi tùy theo từng hàm
        Khi chạy ứng dụng (Global Execution Context)
    Có 3 kiểu ràng buộc this:
        Implicit Binding (Ràng buộc ngầm)
            Thông qua dot notation 
            ex: john.sum(10, 20);
        Explicit Binding (Ràng buộc tường minh)
            Do lập trình viên quyết định
            Sử dụng các method có sẵn (built-in) của Javascript
                .bind(this)
                .call(this, arg1, arg2, ...)
                .apply(this, [arg1, arg2, ...])
        Default Binding (Ràng buộc mặc định)
            Mặc định ràng buộc globalThis = window
            ex:
                var func = john.sum;
                func(10, 20);
            Trường hợp mặc định này thì nó cũng đúng với các function bình thường khi gọi biến this trong function đó 
Explicit Binding, bind, call và apply
    Bind
        Là 1 method có sãn của Javascript, truyền vào 1 object bất kỳ. Object này sẽ được ràng buộc vào biến this 
        Khi gọi hàm bind() thì nó sẽ trả về 1 function mới đã được dàng buộc cố định object mà mình đã truyền vào 
        Có thể sử dụng hàm bind này để cố định this
    Call và apply
        Nhận vào một object bất kỳ trong tham số đầu tiên
        Function này sẽ được gọi ngay lập tức
        Return về kết quả của lời gọi hàm
Practice 04
    Arrow function không được ràng buộc this:
        Phụ thuộc vào nơi khai báo function
        Sử dụng this như là scope của function bên ngoài. 
            this của arrow function được coi như là Closure ở bên ngoài tức là Scope Chain ở bên ngoài
            -> chính là this của function bên ngoài nó 
        Để có thể truy cập được this chính là object hiện tại thì không được phép khai báo là arrow function
Strict mode
    const btnEl = document.getElementById('test-this')
    const john = {
        addEvent() {
            btnEl.addEventListener('click', this.handleClick);
        },
        handleClick() {
            console.log('handleClick', this);
        }
    }
    this.handleClick ở đây thực hiện vai trò truyền hàm vào Javascript Dom chứ ko phải thực hiện gọi hàm theo kiểu dot notation.
        Khi trình duyệt nhận diện được sự kiện của người dùng là click thì môi trường trình duyệt và môi trường Dom giúp ta gọi 
            hàm này
    
            ==========================================================================================================

                        Asynchronous Programming

Concurrency, Parallelism
    Concurrency (Đồng thời): Là khi hai hay nhiều tác vụ có thể bắt đầu xử lý, đang xử lý và hoàn tất trong
        khoảng thời gian chồng chéo lên nhau.(overlapping time).
        Trong 1 thời điểm nó chỉ xử lý 1 task vụ thôi, nếu task vụ này quá tốn thời gian, cần phải chờ thì có thể tạm dừng task 
            vụ đó để chèn task vụ khác lên và xử lý tiếp. Khi task vụ khác xử lý xong thì sẽ quay trở lại task vụ đang chờ để xủ lý
    Parallelism (Song song): Là khi hai hay nhiều tác vụ có thể bắt đầu xử lý, đang xử lý và hoàn tất trong
        chính xác cùng một thời điểm -> Java
    Javascript Concurrency Modal
Single Thread và Blocking
    Javascript là ngôn ngữ lập trình đơn luồng.
    Đơn luồng: Tại một thời điểm chỉ có duy nhất một câu lệnh được thực thi.
    Thực thi theo kiểu đồng bộ từng dòng
    Blocking: Javascript chỉ xử lý đơn luồng nên dẫn đến vấn đề là Blocking, là đoạn code sẽ bị chặn khi mà đoạn code ở phía trên chưa 
        xử lý xong
SetTimeout và những hiện tượng lạ
    Các thành phần cốt lõi của Javascript:
        Thread of execution
        Memory/variable environment
        Call stack
    Chúng ta cần thêm nhiều thành phần nữa để xử lý:
        Web APIs(browser)
        Event loop
        Callback queues
            Macro task queue and micro task queue
Concurrency model trong Javascript
    SetTimeout là của Web APIs(browser) chứ không phải là của Javascript vì nếu là của Javascript thì nó phải thỏa mãn cơ chế
        Single Thread. Tính năng thật sự của browser đó là Timers là bộ đếm của trình duyệt
    Timers thực hiện đếm thời gian, nếu hết thời gian thì tham số hàm được truyền trong SetTimeout sẽ được gửi xuống 
        Callbacks queue.
    Một mình Javascript thì nó là Single Thread nhưng với sự hỗ trợ của trình duyệt thì 2 task được thực hiện song song 
        trong quá trình Javascript Engine thực hiện task vụ thì Timers thực hiện đếm song song
    Event loop là vòng lặp vô hạn, nó sẽ liên tục kiểm tra nếu như Call Stack rỗng, nghĩa là chương trình chạy song rồi không còn 
        không còn code đồng bộ nào của Javascript để chạy thì mới cho phép hàm được set ở trong Callbacks queue đưa 
        lên để thực thi. Khi được đưa lên để thực thi thì nó sẽ giống như Javascript thông thường
Event Loop và Callback Queues
Practice
    Practice 01
        Yêu cầu Challenge 01:
            1. Các lời gọi API sẽ có thời gian chạy khác nhau và ngâu nhiên
            2. Kết quả phải được hiển thị ra cho người dùng theo đúng thứ tự 1 -> 2 -> 3
    Practice 01 - Solution
    Practice 02
        Yêu cầu:
            Các lời gọi API sẽ có thời gian chạy khác nhau và ngẫu nhiên.
            Cả 3 lời gọi API phải được chạy đồng thời cùng một lúc.
            Chỉ áp dụng các kiến thức cơ bản của Javascript (Không dùng Promise)
            API nào chạy xong phải in kết quả ra ngay (Nhưng phải đảm bảo đúng thứ tự 1->2->3)
    Practice 02 - Solution
        Higher Order Function, Callback
Design Pattern(Thunk Pattern)
    Thunk chỉ là một tên gọi khác của Function
    Function này là một dạng Function với ứng dụng đặc biệt
    Thunk là một function có thể delay quá trình đánh giá biểu thức ra giá trị khi xử lý trong Javascript
    Normal
        // sub là một function thông thường
        function sum(a, b) { return a + b }
        // gọi hàm in ra ngay giá trị biểu thức 10 + 20
        console.log( sum(10, 20) );
    Thumb 
        // function dùng để tạo ra một thunk
        function createThunk() {
            let result = sum(10, 20);
            return function() {
                return result;
            }
        }
        // Tạo thunk và xử lý ra kêt qua
        let thunkFn = createThunk();
        // Delay việc lâ ́y kêt qua Khi gọi thunk thì mới có data
        let result = thunkFn();
Callback Hell
    Callback tồn tại 2 vấn đề cần phải cải thiện:
        1. Xử lý lỗi (Error handling issues)
        2. Giao quyền kiểm soát chương trình cho bên thứ 3 (Trust Issues)
    

            ==========================================================================================================

                        Promise

Micro Tasks và Macro Tasks Queue
    Callback Queues bao gồm hai loại hàng đợi (Queues) với thứ tự ưu tiên khác nhau
        Tasks Queue - Macro Tasks Queue
        Micro Tasks Queue
    Điểm giống nhau của hai loại hàng đợi này là các tác vụ thực thi cần phải xếp hàng chờ khi Call Stack đang xử 
        lý. Một khi Call Stack rỗng thì các tác vụ mới được phép di chuyển lần lượt để thực thi sau mỗi event loop.
    Điểm khác biệt ở đây là xét về thứ tự ưu tiên. Micro Tasks sẽ có độ ưu tiên thực thi cao hơn Macro Tasks.
    Các dạng Macro Tasks thường gặp: Hàm Callback từ sự kiện người dùng (Click, Scroll, ...). Hàm truyền vào 
        setTimeout(), setInterval()
    Các dạng Micro Tasks: Dùng với Promise. Hàm truyền vào queueMicrotask()
Queue_micro_task
Fetch và Promise
Promise và Patterns
    Thunk là một function cho phép delay quá trình lấy dữ liệu
    Promise là một Object cũng cho phép delay quá trình lấy dữ liệu
    Điểm đặc biệt của Promise là tất cả các function callback được gửi sang Web APIs để chờ
    Sau khi Web APIs thực hiện lời gọi HTTP hoàn tất, Web APIs sẽ chuyển function callback ngược xuống
        Callback Queues để chờ xử lý.
    Cụ thể là sẽ đưa vào Micro Tasks Queue
Challenge Promise
    Practice 01
        Micro Tasks Queue có độ ưu tiên cao hơn Macro Tasks Queue. Nhưng độ ưu tiên cao hơn ở đây là tại cùng 1 thời điểm 
            2 hàm cùng nằm trong Queue thì Micro Tasks Queue sẽ được ưu tiên trước
        Ex:
            SetTimeout: 0.1ms -> Callback function được chuyển vào Macro
            Fetch hết 1ms -> Callback function được chuyển vào Micro 
        2 Callback function này được đưa vào tại 2 thời điểm khác nhau nên khi Event Loop liên tục kiểm tra thì khi kiểm tra đến Queue 
            của Macro thì khi đó Queue của Micro vẫn đang là 1 Queue rỗng
    Practice 02
        block5Seconds(): Thêm 1 đoạn code blocking Javascript, không dùng tính năng nào của Web APIs cả nên nó là code đồng bộ ở trong 
            Javascript
        Sau khi chạy hết các đoạn code đồng bộ của Javascript thì SetTimeout và fetch mới được chạy 
    Practice 03
Promise Chain
    Khi hàm Promise.prototype.then() được thực hiện và gửi kèm theo các Call Back cần thiết thì bản
        thân nó cũng trả về một Promise.
    Promise cho phép xử lí một chuỗi nhiều các tác vụ bất đồng bộ liên tiếp nhau.
Promise Constructor
    Promise() Constructor là một cách chính thức từ Javascript hỗ trợ cho lập trình viên có thể sử dụng tính
        năng của Promise trong các Functions bất đồng bộ bằng cách Wrap các Functions đó nếu nó chưa hỗ
        trợ Promises.
    Trong Javascript hay trong Web APIs thì SetTimeout, setInterval, event... thì chưa hỗ trợ Promise
    Sử dụng từ khóa new để khởi tạo một Object Promise mới
Promise All
    Promise.all(iterable) là một phương thức của Object Promise giúp chạy đồng thời nhiều tác vụ cùng một lúc
    Tham số truyền vào là một iterable - Tức là một array có thể lặp.
    Mỗi phần tử của Array chính là một Promise khác
    Promise.all(iterable) sẽ return về một Promise mới sẽ kết thúc khi:
        Toàn bộ Promise trong Array truyền vào hoàn tất.
        Ít nhất trong số Promise trong Array bị lỗi.
    Kết quả thành công sau khi xử lý chứa trong Promise mới trả về cũng là một Array theo thứ tự giống tự
        iterable truyền vào
Practice 04
    Đối với Promise All thì sẽ in ra 1 lượt 3 kết quả luôn, thời gian in là thời gian của kết Promise lâu nhất
    Yêu cầu:
        1. Các lời gọi API sẽ có thời gian chạy khác nhau và ngẫu nhiên.
        2. Cả 3 lời gọi API phải được chạy đồng thời cùng một lúc.
        3. Chỉ áp dụng các kiến thức liên quan tới Promise.
        4. API nào chạy xong phải in kết quả ra ngay (Nhưng phải đảm bảo đúng thứ tự 1->2->3)
Recap Promise
    Promise là một Object đặc biệt của Javascript(Không phải của Web APIs) đại diện cho một tác vụ được xử lý bất đồng bộ, và nó chứa giá trị trả về
        cũng như là các giá trị lỗi xảy ra từ tác vụ đó.
    Promise sinh ra để giải quyết các vấn đề của Callback và Callback Hell
    Callback Hell gặp 2 vấn đề chính:
        Handle Error
        Trust Issues
    
            ==========================================================================================================

                        Iterators, Generators và Async Await

Iteration Protocols
    Iterators và Generators là các khái niệm cốt lõi, cội nguồn để chúng ta hiểu được cách Async và Await hoạt động
    Async Await là tính năng mới xuất hiện trong Javascript ES7
    Iteration protocols:
        Đây không phải là cú pháp mới được xây dựng trong Javascript
        Iteration Protocols chỉ là những giao thức mới xuất hiện trong ES6 cho phép lập trình viên có thể tự định
            nghĩa cách thức lặp của một Object bất kỳ
        Bản chất Array cũng đã hiện thực giao thức này ngầm ở bên dưới, do đó chúng ta có thể sử dụng những
            tính năng mới để lặp qua một Array như forEach(), for..in, for..of, map(), ...
        Để áp dụng các giao thức này chúng ta cần tuân thủ quy tắc của 2 giao thức mà Javascript cung cấp:
            Iterable protocol và Iterator protocol
    Xây dựng:
        Lặp từng phần tử của Array theo thời gian không cố định
        Khi nào gọi hàm next() thì sẽ lặp một lần
        next() trả về một object có value và done
            value là giá trị mỗi phần tử
            done là giá trị boolean cho biết còn lặp được nữa hay không?
Practice 01
Iterable và Iterator Protocol
    Iterable và Iterator protocol nằm trong nhóm các giao thức Iteration Protocols
    Ví dụ một Object được gọi là Iterable (Có thể lặp): Array, String, ...
    Object này chỉ cần tuân thủ một số quy tắc sau đây
        Có hiện thực (khai báo) một phương thức đặc biệt (Method)
        Method này có key là một hằng số Symbol.iterator được cung cấp sẵn bởi Javascript
        Method này không có tham số truyền vào
        Method này khi được gọi sẽ return về một Iterator Object
    Một Object được coi là một Iterator nếu nó tuân thủ các quy tắc sau đây:
        Có hiện thực hàm next() là method của nó
        Hàm next() không nhận vào tham số nhưng khi được gọi sẽ trả về một Object có hai thuộc tính
            value và done
Practice 02
Symbol
    Bản đặc tả ngôn ngữ từ ECMA:
        https://262.ecma-international.org/11.0/#sec-ecmascript-language-types-symbol-type
    Kiểu dữ liệu symbol có thể được sử dụng làm key của một Object, đóng vai trò là thuộc tính của Object đó
    Mỗi giá trị Symbol được tạo ra có giá trị độc nhất vô nhị (Không bao giờ bị trùng với những giá trị khác)
        và không thể thay đổi được
    Ứng dụng:
        Tạo ra các Hidden Properties (Như trong Promise)
        Đảm bảo sự an toàn của một Object khi trao đổi qua các môi trường khác nhau -> Trust issues
    